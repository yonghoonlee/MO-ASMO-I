%===============================================================================
% Multiobjective Adaptive Surrogate Modeling-based Optimization Code I
% Main author: Yong Hoon Lee (ylee196@illinois.edu, yonghoonlee@outlook.com)
% Link: https://github.com/yonghoonlee/MO-ASMO-I
%===============================================================================
% Generates samples to exploit the vicinity of the predicted Pareto set.
%===============================================================================
function xf = samplingExploitation(xP, prob)
    if (prob.control.verbose > 0)
        fprintf('Generating samples to exploit the current solutions...');
    end
    %---------------------------------------------------------------------------
    method = prob.sampling.upmethod;
    number = prob.sampling.upnumber;
    %---------------------------------------------------------------------------
    switch lower(method)
        case 'fdl' % Force directed layout
            xt = samplingFDL(xP,number,prob);
        case 'cdd' % Cartesian domain division
            xt = samplingCDD(xP,number,prob);
        otherwise
            error(strcat(method,'::not supported.'));
    end
    %---------------------------------------------------------------------------
    A = prob.lincon.A;
    b = prob.lincon.b;
    Aeq = prob.lincon.Aeq;
    beq = prob.lincon.beq;
    lb = prob.bound.xlb;
    ub = prob.bound.xub;
    nonlconfun = prob.function.nonlconfun;
    p = prob.param;
    opt = prob.sampling.initconopt;
    %---------------------------------------------------------------------------
    % Sample adjustment (to satisfy constraints)
    fprintf('%s','adjust samples to satisfy constraints...');
    xf = xt;
    if (prob.control.verbose == 2); fprintf('\n'); end
    for i = 1:size(xt,1)
        xtmp = xt(i,:);
        [xs,f,e,o] = fmincon( ...
            @(x)samplingCObj(x,xtmp),...
            xtmp,A,b,Aeq,beq,lb,ub,@(x)nonlconfun(x,p),opt);
        xf(i,:) = reshape(xs,1,numel(xs));
        if (prob.control.verbose == 2)
            disp(strcat('exitflag:',num2str(e),...
                '/objfn:',num2str(f),...
                '/constrviolation:',num2str(o.constrviolation)));
        end
    end
    %---------------------------------------------------------------------------
    if (prob.control.verbose == 2)
        fprintf('...');
    end
    if (prob.control.verbose > 0)
        fprintf('%s\n','done');
    end
    %===========================================================================
    function f = samplingCObj(x,x0)
        f = sum((x - x0).^2);
    end
    %===========================================================================
end
%===============================================================================
% Force-directed layout sampling
%===============================================================================
function xf = samplingFDL(xP,number,prob)
    if (prob.control.verbose > 0)
        fprintf('Force-directed layout method...');
    end
    %---------------------------------------------------------------------------
    % Scale [0 1]
    nxP = size(xP,1);
    mxP = size(xP,2);
    xPlb = min(xP)-1e-10;
    xPub = max(xP)+1e-10;
    xPS = (xP - repmat(xPlb,nxP,1))./repmat((xPub - xPlb),nxP,1);
    %---------------------------------------------------------------------------
    xB = [];
    if number > 3
        nbounding = ceil(0.2*number); % 20% for bounding points
        nothers = number - nbounding; % rest for interior points
    else
        nbounding = 0;
        nothers = number;
    end
    %---------------------------------------------------------------------------
    % Find bounding points
    if (nbounding ~= 0)
        xC = 0.5*ones(size(xPlb)); % Scaled center should be 0.5
        distC = sqrt(sum((xPS - repmat(xC,nxP,1)).^2,2));
        [~,idistC] = sort(distC,'descend'); % Get index in larger first
        nb = min(nbounding,length(distC));
        for i = 1:nb
            xB = [xB; xPS(idistC(i),:)];
        end
    end
    %---------------------------------------------------------------------------
    % Find clusterred centers
    if (nothers >= size(xPS,1))
        nothers = size(xPS,1)-1;
    end
    if ((nothers > 0) && (size(xPS,1) > nothers))
        [~,xtmp,~] = kmeans(xPS,nothers);
    else
        xtmp = xPS;
    end
    xB = [xB; xtmp];
    number = size(xB,1);
    %---------------------------------------------------------------------------
    % Generate nearby points to the xB
    pm = rand(size(xB)); pm(pm<0.5) = -1; pm(pm>=0.5) = 1;
    xM = xB + 0.1*pm;
    vM = zeros(size(xM));
    %---------------------------------------------------------------------------
    for iloop = 1:500
        % Run FDL
        % Peter Eades, "A heuristic for graph drawing,"
        % Congressus Numerantium, 42:149-160, 1984.
        ForceSpring = zeros(number,mxP);
        %-----------------------------------------------------------------------
        % Attractive and repulsive forces between Base point (xB) and Moving point (xM)
        % Log spring force
        C1BM = 2; C2BM = 1.25/exp(1); % force balances if distance is 1.25
        distBM = sqrt(sum((xB - xM).^2,2));
        forceBM = C1BM * log(distBM./C2BM);
        vectorBM = (xB - xM)./repmat(distBM,1,mxP);
        ForceSpring = ForceSpring + vectorBM.*repmat(forceBM,1,mxP);
        %-----------------------------------------------------------------------
        % Repulsive forces between Pareto points (xPS) and Moving points (xM)
        % Inverse square law force
        C3PM = 1e-6;
        for i = 1:number
            for j = 1:nxP
                distPM = sqrt(sum((xM(i,:) - xPS(j,:)).^2));
                vectorPM = (xM(i,:) - xPS(j,:))./repmat(distPM,1,mxP);
                forcePM = C3PM/distPM^2;
                ForceSpring(i,:) = ForceSpring(i,:) + vectorPM * forcePM;
            end
        end
        %-----------------------------------------------------------------------
        % Dynamics
        mass = 1;
        timestep = 1/(1+log(iloop));
        vM = vM + ForceSpring/mass*timestep;
        vM(vM>0.1) = 0.1;
        vM(vM<-0.1) = -0.1;
        vM = vM / 1.1; % Velocity diminishing
        xM = xM + vM*timestep;
        %-----------------------------------------------------------------------
        % Stopping
        if max(sqrt(sum(vM.^2,2))) < 1e-2
            break;
        end
    end
    %---------------------------------------------------------------------------
    nxM = size(xM,1);
    xf = repmat(xPlb,nxM,1) + (repmat(xPub,nxM,1) - repmat(xPlb,nxM,1)).*xM;
end
%===============================================================================
% Cartesian domain division sampling
%===============================================================================
function xf = sampling_CDD(xP,number,prob)
    if (prob.control.verbose > 0)
        fprintf('Cartesian domain division method...');
    end
    %---------------------------------------------------------------------------
    minxP = min(xP);
    maxxP = max(xP);
    minD = minxP - 0.5*(maxxP - minxP);         % expand 50%
    maxD = maxxP + 0.5*(maxxP - minxP);         % expand 50%
    minD = max([minD; prob.bound.xlb']);        % limit to lb
    maxD = min([maxD; prob.bound.xub']);        % limit to ub
    sizeD = maxD - minD;
    %---------------------------------------------------------------------------
    i = 0;
    flg = true;
    %---------------------------------------------------------------------------
    while (flg)
        i = i + 1;
        %-----------------------------------------------------------------------
        % Generate list of all point combinations
        clear blist;
        clear clist;
        clear dlist;
        xlist = [];
        for j = 1:i+1
            blist(j,:) = [minD + (j-1)*sizeD/i];
        end
        for k = 1:size(blist,2)
            for j = 1:size(blist,1)
                clist{k}(1,j) = blist(j,k);
            end
        end
        dlist = [combvec(clist{:})]';
        %-----------------------------------------------------------------------
        % Check the distance from existing points
        for j = 1:size(dlist,1)
            flg = false;
            for k = 1:size(xP,1)
                distance = abs(dlist(j,:)-xP(k,:));
                if (all(distance < 0.05*sizeD)) % 5% threshold
                    flg = true;
                end
            end
            if (flg == true)
                xlist = [xlist; dlist(j,:)];
            end
        end
        %-----------------------------------------------------------------------
        if (size(xlist,1) >= number)
            flg = false;
        else
            flg = true;
        end
    end
    %---------------------------------------------------------------------------
    xf = util_reducepoints(xlist,n,'RND');
    %---------------------------------------------------------------------------
    % 1% distance randomize
    rx = (2*(rand(size(xf))-0.5)).*(ones(size(xf,1),1)*(0.01*sizeD));
    xf = xf + rx;
end
%===============================================================================
